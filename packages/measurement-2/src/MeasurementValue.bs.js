// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Belt_SortArray = require("bs-platform/lib/js/belt_SortArray.js");
var Result$Rationale = require("rationale/src/Result.js");
var Utils$Measurement = require("./Utils.bs.js");
var Function$Rationale = require("rationale/src/Function.js");

function fromString(e) {
  switch (e) {
    case "AMBIGUOUS" : 
        return /* AMBIGUOUS */-974356372;
    case "FALSE_CONDITIONAL" : 
        return /* FALSE_CONDITIONAL */606665514;
    case "OTHER" : 
        return /* OTHER */879009456;
    case "RESULT_NOT_AVAILABLE" : 
        return /* RESULT_NOT_AVAILABLE */-8423941;
    default:
      return Js_exn.raiseError("Invalid GraphQL Unresolvable Resolution: " + e);
  }
}

function toString(e) {
  if (e >= 606665514) {
    if (e >= 879009456) {
      return "OTHER";
    } else {
      return "FALSE_CONDITIONAL";
    }
  } else if (e >= -8423941) {
    return "RESULT_NOT_AVAILABLE";
  } else {
    return "AMBIGUOUS";
  }
}

function toPublicString(e) {
  if (e >= 606665514) {
    if (e >= 879009456) {
      return "Other";
    } else {
      return "False Conditional";
    }
  } else if (e >= -8423941) {
    return "Result Not Available";
  } else {
    return "Ambiguous";
  }
}

var UnresolvableResolution = /* module */[
  /* fromString */fromString,
  /* toString */toString,
  /* toPublicString */toPublicString
];

function fromString$1(e) {
  switch (e) {
    case "GENERIC" : 
        return /* GENERIC */909067767;
    case "QUESTION_FEEDBACK" : 
        return /* QUESTION_FEEDBACK */-527079426;
    case "UPDATE" : 
        return /* UPDATE */965227017;
    default:
      return Js_exn.raiseError("Invalid GraphQL Comment: " + e);
  }
}

function toString$1(e) {
  if (e !== 909067767) {
    if (e >= 965227017) {
      return "UPDATE";
    } else {
      return "QUESTION_FEEDBACK";
    }
  } else {
    return "GENERIC";
  }
}

function toPublicString$1(e) {
  if (e !== 909067767) {
    if (e >= 965227017) {
      return "Update";
    } else {
      return "Question Feedback";
    }
  } else {
    return "Generic";
  }
}

var $$Comment = /* module */[
  /* fromString */fromString$1,
  /* toString */toString$1,
  /* toPublicString */toPublicString$1
];

function MakeCdf(Item) {
  var cmp = Caml_obj.caml_compare;
  var Id = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);
  var toArrays = function (t) {
    return /* tuple */[
            Belt_Map.keysToArray(t),
            Belt_Map.valuesToArray(t)
          ];
  };
  var toDict = function (t) {
    return Js_dict.fromArray($$Array.map((function (param) {
                      return /* tuple */[
                              Pervasives.string_of_float(param[0]),
                              param[1]
                            ];
                    }), Belt_Map.toArray(t)));
  };
  var fromArray = function (a) {
    return (function (param) {
                return Belt_Map.fromArray(param, Id);
              })(a);
  };
  var sortArrayByXs = function (tArray) {
    return Belt_SortArray.stableSortBy(tArray, (function (param, param$1) {
                  return Curry._2(Item[/* compare */1], param[1], param$1[1]);
                }));
  };
  var toPoints = function (t) {
    return $$Array.map((function (param) {
                  return {
                          y: param[0],
                          x: param[1]
                        };
                }), sortArrayByXs(Belt_Map.toArray(t)));
  };
  var toJss = function (t) {
    return {
            ys: Belt_Map.keysToArray(t),
            xs: Belt_Map.valuesToArray(t)
          };
  };
  var toJs = function (t) {
    var points = sortArrayByXs(Belt_Map.toArray(t));
    return {
            xs: $$Array.map((function (param) {
                    return param[1];
                  }), points),
            ys: $$Array.map((function (param) {
                    return param[0];
                  }), points)
          };
  };
  var fromDict = function (r) {
    return (function (param) {
                return Belt_Map.fromArray(param, Id);
              })($$Array.map((function (param) {
                      return /* tuple */[
                              Caml_format.caml_float_of_string(param[0]),
                              param[1]
                            ];
                    }), Js_dict.entries(r)));
  };
  var fromArrays = function (a) {
    return fromDict(Js_dict.fromArray($$Array.map((function (param) {
                          return /* tuple */[
                                  Pervasives.string_of_float(param[1]),
                                  param[0]
                                ];
                        }), Belt_Array.zip(a[0], a[1]))));
  };
  var dataDecoder = function (j) {
    var partial_arg = Item[/* decodeFn */3];
    var xs = Json_decode.field("xs", (function (param) {
            return Json_decode.array(partial_arg, param);
          }), j);
    var ys = Json_decode.field("ys", (function (param) {
            return Json_decode.array(Json_decode.$$float, param);
          }), j);
    return Js_dict.fromArray($$Array.map((function (param) {
                      return /* tuple */[
                              Pervasives.string_of_float(param[1]),
                              param[0]
                            ];
                    }), Belt_Array.zip(xs, ys)));
  };
  var partial_arg = Function$Rationale.Infix[/* ||> */1];
  var partial_arg$1 = function (param) {
    return partial_arg((function (param) {
                  return Json_decode.field("data", dataDecoder, param);
                }), fromDict, param);
  };
  var decode = function (param) {
    return Utils$Measurement.decodeResult(partial_arg$1, param);
  };
  var xs = function (t) {
    return toArrays(t)[0];
  };
  var ys = function (t) {
    return toArrays(t)[1];
  };
  var xsEncoded = function (t) {
    return $$Array.map((function (prim) {
                  return prim;
                }), xs(t));
  };
  var ysEncoded = function (t) {
    return $$Array.map(Item[/* encodeFn */2], ys(t));
  };
  var dataEncoder = function (t) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "xs",
                  $$Array.map((function (prim) {
                          return prim;
                        }), xs(t))
                ],
                /* :: */[
                  /* tuple */[
                    "ys",
                    ysEncoded(t)
                  ],
                  /* [] */0
                ]
              ]);
  };
  var encode = function (name, t) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "dataType",
                  name
                ],
                /* :: */[
                  /* tuple */[
                    "data",
                    dataEncoder(t)
                  ],
                  /* [] */0
                ]
              ]);
  };
  return /* module */[
          /* Id */Id,
          /* toArray */Belt_Map.toArray,
          /* toArrays */toArrays,
          /* toDict */toDict,
          /* fromArray */fromArray,
          /* sortArrayByXs */sortArrayByXs,
          /* toPoints */toPoints,
          /* toJss */toJss,
          /* toJs */toJs,
          /* fromDict */fromDict,
          /* fromArrays */fromArrays,
          /* dataDecoder */dataDecoder,
          /* decode */decode,
          /* xs */xs,
          /* ys */ys,
          /* xsEncoded */xsEncoded,
          /* ysEncoded */ysEncoded,
          /* dataEncoder */dataEncoder,
          /* encode */encode
        ];
}

function equal(a, b) {
  return a === b;
}

function compare(a, b) {
  var match = a > b;
  if (match) {
    return 1;
  } else {
    return -1;
  }
}

function encodeFn(prim) {
  return prim;
}

var FloatPoint = /* module */[
  /* equal */equal,
  /* compare */compare,
  /* encodeFn */encodeFn,
  /* decodeFn */Json_decode.$$float
];

var cmp = Caml_obj.caml_compare;

var Id = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

function toArrays(t) {
  return /* tuple */[
          Belt_Map.keysToArray(t),
          Belt_Map.valuesToArray(t)
        ];
}

function toDict(t) {
  return Js_dict.fromArray($$Array.map((function (param) {
                    return /* tuple */[
                            Pervasives.string_of_float(param[0]),
                            param[1]
                          ];
                  }), Belt_Map.toArray(t)));
}

function fromArray(a) {
  return (function (param) {
              return Belt_Map.fromArray(param, Id);
            })(a);
}

function sortArrayByXs(tArray) {
  return Belt_SortArray.stableSortBy(tArray, (function (param, param$1) {
                return compare(param[1], param$1[1]);
              }));
}

function toPoints(t) {
  return $$Array.map((function (param) {
                return {
                        y: param[0],
                        x: param[1]
                      };
              }), sortArrayByXs(Belt_Map.toArray(t)));
}

function toJss(t) {
  return {
          ys: Belt_Map.keysToArray(t),
          xs: Belt_Map.valuesToArray(t)
        };
}

function toJs(t) {
  var points = sortArrayByXs(Belt_Map.toArray(t));
  return {
          xs: $$Array.map((function (param) {
                  return param[1];
                }), points),
          ys: $$Array.map((function (param) {
                  return param[0];
                }), points)
        };
}

function fromDict(r) {
  return (function (param) {
              return Belt_Map.fromArray(param, Id);
            })($$Array.map((function (param) {
                    return /* tuple */[
                            Caml_format.caml_float_of_string(param[0]),
                            param[1]
                          ];
                  }), Js_dict.entries(r)));
}

function fromArrays(a) {
  return fromDict(Js_dict.fromArray($$Array.map((function (param) {
                        return /* tuple */[
                                Pervasives.string_of_float(param[1]),
                                param[0]
                              ];
                      }), Belt_Array.zip(a[0], a[1]))));
}

function dataDecoder(j) {
  var xs = Json_decode.field("xs", (function (param) {
          return Json_decode.array(Json_decode.$$float, param);
        }), j);
  var ys = Json_decode.field("ys", (function (param) {
          return Json_decode.array(Json_decode.$$float, param);
        }), j);
  return Js_dict.fromArray($$Array.map((function (param) {
                    return /* tuple */[
                            Pervasives.string_of_float(param[1]),
                            param[0]
                          ];
                  }), Belt_Array.zip(xs, ys)));
}

var partial_arg = Function$Rationale.Infix[/* ||> */1];

function partial_arg$1(param) {
  return partial_arg((function (param) {
                return Json_decode.field("data", dataDecoder, param);
              }), fromDict, param);
}

function decode(param) {
  return Utils$Measurement.decodeResult(partial_arg$1, param);
}

function xs(t) {
  return toArrays(t)[0];
}

function ys(t) {
  return toArrays(t)[1];
}

function xsEncoded(t) {
  return $$Array.map((function (prim) {
                return prim;
              }), xs(t));
}

function ysEncoded(t) {
  return $$Array.map(encodeFn, ys(t));
}

function dataEncoder(t) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "xs",
                $$Array.map((function (prim) {
                        return prim;
                      }), xs(t))
              ],
              /* :: */[
                /* tuple */[
                  "ys",
                  $$Array.map(encodeFn, ys(t))
                ],
                /* [] */0
              ]
            ]);
}

function encode(name, t) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "dataType",
                name
              ],
              /* :: */[
                /* tuple */[
                  "data",
                  dataEncoder(t)
                ],
                /* [] */0
              ]
            ]);
}

var FloatCdf = /* module */[
  /* Id */Id,
  /* toArray */Belt_Map.toArray,
  /* toArrays */toArrays,
  /* toDict */toDict,
  /* fromArray */fromArray,
  /* sortArrayByXs */sortArrayByXs,
  /* toPoints */toPoints,
  /* toJss */toJss,
  /* toJs */toJs,
  /* fromDict */fromDict,
  /* fromArrays */fromArrays,
  /* dataDecoder */dataDecoder,
  /* decode */decode,
  /* xs */xs,
  /* ys */ys,
  /* xsEncoded */xsEncoded,
  /* ysEncoded */ysEncoded,
  /* dataEncoder */dataEncoder,
  /* encode */encode
];

function toPdf(t) {
  var inChunks = $$Array.to_list(Belt_Map.toArray(t));
  return fromArray($$Array.of_list(List.mapi((function (i, e) {
                        if (i === 0) {
                          return e;
                        } else {
                          var x = e[1];
                          var match = List.nth(inChunks, i - 1 | 0);
                          var derivative = (e[0] - match[0]) / (x - match[1]);
                          return /* tuple */[
                                  derivative,
                                  x
                                ];
                        }
                      }), inChunks)));
}

function error(t) {
  if (typeof t === "number" || t[0] !== -488794310) {
    return undefined;
  } else {
    var i = t[1];
    if (0.0 <= i && i <= 100.0) {
      return undefined;
    } else {
      return "Must be between 0 and 100";
    }
  }
}

function isValid(t) {
  var match = error(t);
  return match === undefined;
}

function typeToName(t) {
  var variant = t[0];
  if (variant >= -606499532) {
    if (variant >= 564146209) {
      if (variant >= 926191241) {
        return "floatCdf";
      } else {
        return "binary";
      }
    } else if (variant >= -488794310) {
      return "percentage";
    } else {
      return "floatPoint";
    }
  } else if (variant >= -826170817) {
    return "comment";
  } else {
    return "unresolvableResolution";
  }
}

function nameToType(param) {
  switch (param) {
    case "binary" : 
        return /* Ok */Block.__(0, [/* Binary */564146209]);
    case "comment" : 
        return /* Ok */Block.__(0, [/* Comment */-826170817]);
    case "floatCdf" : 
        return /* Ok */Block.__(0, [/* FloatCdf */926191241]);
    case "floatPoint" : 
        return /* Ok */Block.__(0, [/* FloatPoint */-606499532]);
    case "percentage" : 
        return /* Ok */Block.__(0, [/* Percentage */-488794310]);
    case "unresolvableResolution" : 
        return /* Ok */Block.__(0, [/* UnresolvableResolution */-882782856]);
    default:
      return /* Error */Block.__(1, ["Not found"]);
  }
}

function stringOfValue(t) {
  var variant = t[0];
  if (variant !== -826170817) {
    if (variant >= 564146209) {
      if (variant >= 926191241) {
        var t$1 = t[1];
        var per = function (perc) {
          return String(Belt_Map.getWithDefault(t$1, perc, 0.0) | 0);
        };
        var p25 = per(25.0);
        var p50 = per(50.0);
        var p75 = per(75.0);
        return "{25: " + (String(p25) + (", 50: " + (String(p50) + (", 75: " + (String(p75) + "} ")))));
      } else {
        return Pervasives.string_of_bool(t[1]);
      }
    } else if (variant >= -882782855) {
      return Pervasives.string_of_float(t[1]);
    } else {
      return toString(t[1]);
    }
  } else {
    return toString$1(t[1]);
  }
}

function encode$1(e) {
  var n = typeToName(e);
  var variant = e[0];
  if (variant >= -606499532) {
    if (variant >= 564146209) {
      if (variant >= 926191241) {
        return encode(n, e[1]);
      } else {
        return Utils$Measurement.makeEncode((function (prim) {
                      return prim;
                    }), n, e[1]);
      }
    } else if (variant >= -488794310) {
      return Utils$Measurement.makeEncode((function (prim) {
                    return prim;
                  }), n, e[1]);
    } else {
      return Utils$Measurement.makeEncode((function (prim) {
                    return prim;
                  }), n, e[1]);
    }
  } else if (variant >= -826170817) {
    return Utils$Measurement.makeEncode((function (prim) {
                  return prim;
                }), n, stringOfValue(e));
  } else {
    return Utils$Measurement.makeEncode((function (prim) {
                  return prim;
                }), n, stringOfValue(e));
  }
}

function convert(decoder, toValue, json) {
  return Curry._2(Result$Rationale.Infix[/* <$> */1], Curry._1(decoder, json), toValue);
}

function decoder(a, j) {
  if (a >= -606499532) {
    if (a >= 564146209) {
      if (a >= 926191241) {
        return convert(decode, (function (e) {
                      return /* `FloatCdf */[
                              926191241,
                              e
                            ];
                    }), j);
      } else {
        return convert(Utils$Measurement.makeDecode(Json_decode.bool), (function (e) {
                      return /* `Binary */[
                              564146209,
                              e
                            ];
                    }), j);
      }
    } else if (a >= -488794310) {
      return convert(Utils$Measurement.makeDecode(Json_decode.$$float), (function (e) {
                    return /* `Percentage */[
                            -488794310,
                            e
                          ];
                  }), j);
    } else {
      return convert(Utils$Measurement.makeDecode(Json_decode.$$float), (function (e) {
                    return /* `FloatPoint */[
                            -606499532,
                            e
                          ];
                  }), j);
    }
  } else if (a >= -826170817) {
    return convert(Utils$Measurement.makeDecode(Json_decode.string), (function (e) {
                  return /* `Comment */[
                          -826170817,
                          fromString$1(e)
                        ];
                }), j);
  } else {
    return convert(Utils$Measurement.makeDecode(Json_decode.string), (function (e) {
                  return /* `UnresolvableResolution */[
                          -882782856,
                          fromString(e)
                        ];
                }), j);
  }
}

function decode$1(j) {
  var t = Json_decode.field("dataType", Json_decode.string, j);
  var decodingType = nameToType(t);
  if (decodingType.tag) {
    return /* Error */Block.__(1, [decodingType[0]]);
  } else {
    return decoder(decodingType[0], j);
  }
}

function decodeGraphql(j) {
  var match = j.floatCdf;
  var match$1 = j.floatPoint;
  var match$2 = j.percentage;
  var match$3 = j.binary;
  var match$4 = j.unresolvableResolution;
  var match$5 = j.comment;
  if (match !== undefined) {
    var r = Caml_option.valFromOption(match);
    return /* Ok */Block.__(0, [/* `FloatCdf */[
                926191241,
                fromArrays(/* tuple */[
                      r.xs,
                      r.ys
                    ])
              ]]);
  } else if (match$1 !== undefined) {
    return /* Ok */Block.__(0, [/* `FloatPoint */[
                -606499532,
                match$1
              ]]);
  } else if (match$2 !== undefined) {
    return /* Ok */Block.__(0, [/* `Percentage */[
                -488794310,
                match$2
              ]]);
  } else if (match$3 !== undefined) {
    return /* Ok */Block.__(0, [/* `Binary */[
                564146209,
                match$3
              ]]);
  } else if (match$4 !== undefined) {
    return /* Ok */Block.__(0, [/* `UnresolvableResolution */[
                -882782856,
                match$4
              ]]);
  } else if (match$5 !== undefined) {
    return /* Ok */Block.__(0, [/* `Comment */[
                -826170817,
                match$5
              ]]);
  } else {
    return /* Error */Block.__(1, ["Could not convert"]);
  }
}

function encodeToGraphQLMutation(e) {
  var variant = e[0];
  if (variant >= -606499532) {
    if (variant >= 564146209) {
      if (variant >= 926191241) {
        var k = e[1];
        return {
                floatPoint: undefined,
                floatCdf: {
                  xs: $$Array.map((function (e) {
                          return e;
                        }), xs(k)),
                  ys: $$Array.map((function (e) {
                          return e;
                        }), ys(k))
                },
                percentage: undefined,
                binary: undefined,
                unresolvableResolution: undefined,
                comment: undefined
              };
      } else {
        return {
                floatPoint: undefined,
                floatCdf: undefined,
                percentage: undefined,
                binary: e[1],
                unresolvableResolution: undefined,
                comment: undefined
              };
      }
    } else if (variant >= -488794310) {
      return {
              floatPoint: undefined,
              floatCdf: undefined,
              percentage: e[1],
              binary: undefined,
              unresolvableResolution: undefined,
              comment: undefined
            };
    } else {
      return {
              floatPoint: e[1],
              floatCdf: undefined,
              percentage: undefined,
              binary: undefined,
              unresolvableResolution: undefined,
              comment: undefined
            };
    }
  } else if (variant >= -826170817) {
    return {
            floatPoint: undefined,
            floatCdf: undefined,
            percentage: undefined,
            binary: undefined,
            unresolvableResolution: undefined,
            comment: e[1]
          };
  } else {
    return {
            floatPoint: undefined,
            floatCdf: undefined,
            percentage: undefined,
            binary: undefined,
            unresolvableResolution: e[1],
            comment: undefined
          };
  }
}

exports.UnresolvableResolution = UnresolvableResolution;
exports.$$Comment = $$Comment;
exports.MakeCdf = MakeCdf;
exports.FloatPoint = FloatPoint;
exports.FloatCdf = FloatCdf;
exports.toPdf = toPdf;
exports.error = error;
exports.isValid = isValid;
exports.typeToName = typeToName;
exports.nameToType = nameToType;
exports.stringOfValue = stringOfValue;
exports.encode = encode$1;
exports.convert = convert;
exports.decoder = decoder;
exports.decode = decode$1;
exports.decodeGraphql = decodeGraphql;
exports.encodeToGraphQLMutation = encodeToGraphQLMutation;
/* Id Not a pure module */
