// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Option$Rationale = require("rationale/src/Option.js");
var E$PredictionAnalysis = require("../Utility/E.bs.js");
var MeasurementValueWrapper$PredictionAnalysis = require("./MeasurementValueWrapper.bs.js");

function Make(funarg) {
  var hasType = function (intendedType, t) {
    return MeasurementValueWrapper$PredictionAnalysis.Name[/* toIsFn */2](intendedType)(Curry._1(funarg[/* toMeasurement */1], t));
  };
  var firstElementType = function (t) {
    return Option$Rationale.map(MeasurementValueWrapper$PredictionAnalysis.T[/* toTypeName */0], Option$Rationale.map(funarg[/* toMeasurement */1], Belt_Array.get(t, 0)));
  };
  var filterOnFirstElementType = function (ts) {
    var match = firstElementType(ts);
    if (match !== undefined) {
      var t = match;
      return Belt_Array.keep(ts, (function (param) {
                    return hasType(t, param);
                  }));
    } else {
      return /* array */[];
    }
  };
  var isAllSameType = function (ts) {
    return ts.length === filterOnFirstElementType(ts).length;
  };
  var lengthOfIntendedType = function (intededType, ts) {
    return Belt_Array.keep(ts, (function (param) {
                  return hasType(intededType, param);
                })).length;
  };
  var validateAllSame = function (ts) {
    var match = isAllSameType(ts);
    if (match) {
      return /* Ok */Block.__(0, [ts]);
    } else {
      return /* Error */Block.__(1, ["Must all be the same"]);
    }
  };
  var validateHasLength = function (ts) {
    var match = ts.length !== 0;
    if (match) {
      return /* Ok */Block.__(0, [ts]);
    } else {
      return /* Error */Block.__(1, ["Must have at least one element"]);
    }
  };
  var fromT = function (intendedType, ts) {
    var t = Belt_Array.keep(ts, (function (param) {
            return hasType(intendedType, param);
          }));
    var __x = validateAllSame(t);
    return Belt_Result.flatMap(__x, validateHasLength);
  };
  var fromUniform = function (t) {
    var fn = function (fn1, fn2) {
      return Curry._1(fn2, E$PredictionAnalysis.$$Array[/* concatSome */0]($$Array.map((function (r) {
                            return Curry._2(Option$Rationale.fmap, (function (result) {
                                          return Curry._2(funarg[/* map */0], r, (function (param) {
                                                        return result;
                                                      }));
                                        }), Curry._1(fn1, Curry._1(funarg[/* toMeasurement */1], r)));
                          }), t)));
    };
    var match = Option$Rationale.toExn("This should be impossible.", firstElementType(t));
    if (match >= -488794310) {
      if (match >= 365180284) {
        if (match >= 564146209) {
          return fn(MeasurementValueWrapper$PredictionAnalysis.T[/* toBinary */3], (function (r) {
                        return /* `Binary */[
                                564146209,
                                r
                              ];
                      }));
        } else {
          return fn(MeasurementValueWrapper$PredictionAnalysis.T[/* toFloat */2], (function (r) {
                        return /* `Float */[
                                365180284,
                                r
                              ];
                      }));
        }
      } else if (match >= 3354245) {
        return fn(MeasurementValueWrapper$PredictionAnalysis.T[/* toCdf */1], (function (r) {
                      return /* `Cdf */[
                              3354245,
                              r
                            ];
                    }));
      } else {
        return fn(MeasurementValueWrapper$PredictionAnalysis.T[/* toPercentage */4], (function (r) {
                      return /* `Percentage */[
                              -488794310,
                              r
                            ];
                    }));
      }
    } else if (match >= -826170817) {
      return fn(MeasurementValueWrapper$PredictionAnalysis.T[/* toComment */6], (function (r) {
                    return /* `Comment */[
                            -826170817,
                            r
                          ];
                  }));
    } else {
      return fn(MeasurementValueWrapper$PredictionAnalysis.T[/* toUnresolvable */5], (function (r) {
                    return /* `UnresolvableResolution */[
                            -882782856,
                            r
                          ];
                  }));
    }
  };
  var fromT$1 = function (intendedType, ts) {
    var __x = fromT(intendedType, ts);
    return Belt_Result.map(__x, fromUniform);
  };
  return [
          lengthOfIntendedType,
          [fromT$1]
        ];
}

exports.Make = Make;
/* Option-Rationale Not a pure module */
