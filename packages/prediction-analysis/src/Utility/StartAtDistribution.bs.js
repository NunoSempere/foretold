// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Option$Rationale = require("rationale/src/Option.js");
var Result$Rationale = require("rationale/src/Result.js");
var E$PredictionAnalysis = require("./E.bs.js");
var SortedArray$PredictionAnalysis = require("./SortedArray.bs.js");

function _compareXs(param, param$1) {
  return Caml_obj.caml_compare(param[0], param$1[0]);
}

function _sortXUniq(t) {
  return $$Array.of_list(List.sort_uniq(_compareXs, $$Array.to_list(t[/* pointXY */1])));
}

function make(pointXY, finalX) {
  return /* record */[
          /* finalX */finalX,
          /* pointXY */_sortXUniq(/* record */[
                /* finalX */finalX,
                /* pointXY */pointXY
              ])
        ];
}

function map(fn, t) {
  return /* record */[
          /* finalX */t[/* finalX */0],
          /* pointXY */$$Array.map((function (param) {
                  return /* tuple */[
                          param[0],
                          Curry._1(fn, param[1])
                        ];
                }), t[/* pointXY */1])
        ];
}

function xs(t) {
  return $$Array.map((function (param) {
                return param[0];
              }), t[/* pointXY */1]);
}

function ys(t) {
  return $$Array.map((function (param) {
                return param[1];
              }), t[/* pointXY */1]);
}

function transposeResult(t) {
  var match = Belt_Array.getBy(ys(t), Belt_Result.isError);
  if (match !== undefined) {
    var match$1 = match;
    if (match$1.tag) {
      return /* Error */Block.__(1, [match$1[0]]);
    } else {
      return /* Ok */Block.__(0, [map(Belt_Result.getExn, t)]);
    }
  } else {
    return /* Ok */Block.__(0, [map(Belt_Result.getExn, t)]);
  }
}

function xPointToRelevantPointXY(xPoint, t) {
  var match = Caml_obj.caml_greaterthan(xPoint, t[/* finalX */0]);
  if (match) {
    return undefined;
  } else {
    var __x = Belt_Array.reverse(t[/* pointXY */1]);
    return Belt_Array.getBy(__x, (function (param) {
                  return Caml_obj.caml_lessequal(param[0], xPoint);
                }));
  }
}

function xPointToRelevantPointY(xPoint, t) {
  var __x = xPointToRelevantPointXY(xPoint, t);
  return Belt_Option.map(__x, (function (param) {
                return param[1];
              }));
}

function toSortedArrayTillFinalX(t) {
  var match = xPointToRelevantPointXY(t[/* finalX */0], t);
  if (match !== undefined) {
    var match$1 = match;
    if (Caml_obj.caml_equal(match$1[0], t[/* finalX */0])) {
      return t[/* pointXY */1];
    } else {
      return SortedArray$PredictionAnalysis.concat(t[/* pointXY */1], /* array */[/* tuple */[
                    t[/* finalX */0],
                    match$1[1]
                  ]]);
    }
  }
  
}

function integral(t) {
  var __x = Result$Rationale.ofOption("Necessary values are missing.", toSortedArrayTillFinalX(t));
  return Curry._2(Result$Rationale.fmap, (function (inRanges) {
                var __x = Belt_Array.map(inRanges, (function (param) {
                        var match = param[0];
                        return (param[1][0] - match[0]) * match[1];
                      }));
                return Belt_Array.reduce(__x, 0, (function (a, b) {
                              return a + b;
                            }));
              }), Curry._2(Result$Rationale.bind, __x, E$PredictionAnalysis.$$Array[/* toRanges */2]));
}

function average(t, lowestTime, param) {
  var lowestTime$1 = Option$Rationale.firstSome(lowestTime, SortedArray$PredictionAnalysis.min(xs(t)));
  var highestTime = t[/* finalX */0];
  var match = integral(t);
  if (match.tag) {
    return /* Error */Block.__(1, [match[0]]);
  } else if (lowestTime$1 !== undefined) {
    return /* Ok */Block.__(0, [match[0] / (highestTime - lowestTime$1)]);
  } else {
    return /* Error */Block.__(1, ["Min must exist"]);
  }
}

function relevantXs(a, b) {
  var match = SortedArray$PredictionAnalysis.min(xs(a));
  var match$1 = SortedArray$PredictionAnalysis.min(xs(b));
  var firstCommonMin = match !== undefined && match$1 !== undefined ? Caml_option.some(Caml_obj.caml_min(Caml_option.valFromOption(match), Caml_option.valFromOption(match$1))) : undefined;
  if (firstCommonMin !== undefined) {
    return SortedArray$PredictionAnalysis.filterOutLessThan(Caml_option.valFromOption(firstCommonMin), SortedArray$PredictionAnalysis.concat(xs(a), xs(b)));
  } else {
    return /* array */[];
  }
}

function product(t1, t2) {
  var xs = relevantXs(t1, t2);
  return /* record */[
          /* finalX */Caml_obj.caml_min(t1[/* finalX */0], t2[/* finalX */0]),
          /* pointXY */E$PredictionAnalysis.$$Array[/* concatSome */0]($$Array.map((function (x) {
                      var match = xPointToRelevantPointY(x, t1);
                      var match$1 = xPointToRelevantPointY(x, t2);
                      if (match !== undefined && match$1 !== undefined) {
                        return /* tuple */[
                                x,
                                /* tuple */[
                                  Caml_option.valFromOption(match),
                                  Caml_option.valFromOption(match$1)
                                ]
                              ];
                      }
                      
                    }), xs))
        ];
}

function fromT(param) {
  return {
          finalX: param[/* finalX */0],
          points: $$Array.map((function (param) {
                  return {
                          x: param[0],
                          y: param[1]
                        };
                }), param[/* pointXY */1])
        };
}

var JS = [];

var toJs = fromT;

exports.make = make;
exports.xPointToRelevantPointXY = xPointToRelevantPointXY;
exports.product = product;
exports.map = map;
exports.transposeResult = transposeResult;
exports.integral = integral;
exports.average = average;
exports.JS = JS;
exports.toJs = toJs;
/* Option-Rationale Not a pure module */
