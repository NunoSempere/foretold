// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Cdf$PredictionAnalysis = require("../Measurement/Cdf.bs.js");
var Percentage$PredictionAnalysis = require("../Measurement/Percentage.bs.js");
var Distribution$PredictionAnalysis = require("../Measurement/Distribution.bs.js");
var CdfLibraryImporter$PredictionAnalysis = require("../Utility/CdfLibraryImporter.bs.js");

function marketCdfCdf(sampleCount, param) {
  return CdfLibraryImporter$PredictionAnalysis.PredictionResolutionGroup[/* logScoreMarketCdfCdf */0](sampleCount, Cdf$PredictionAnalysis.toDistribution(param[/* agentPrediction */0]), Cdf$PredictionAnalysis.toDistribution(param[/* marketPrediction */1]), Cdf$PredictionAnalysis.toDistribution(param[/* resolution */2]));
}

function nonMarketCdfCdf(sampleCount, param) {
  return CdfLibraryImporter$PredictionAnalysis.PredictionResolutionGroup[/* logScoreNonMarketCdfCdf */1](sampleCount, Cdf$PredictionAnalysis.toDistribution(param[/* agentPrediction */0]), Cdf$PredictionAnalysis.toDistribution(param[/* resolution */2]));
}

function marketCdfFloat(param) {
  var resolution = param[/* resolution */2];
  var pdfY = function (e) {
    return Curry._2(Distribution$PredictionAnalysis.T[/* findY */3], resolution, Cdf$PredictionAnalysis.toPdf(e));
  };
  var agentPrediction = pdfY(param[/* agentPrediction */0]);
  var marketPrediction = pdfY(param[/* marketPrediction */1]);
  return Math.log2(agentPrediction / marketPrediction);
}

function nonMarketCdfFloat(param) {
  return Math.log2(Curry._2(Distribution$PredictionAnalysis.T[/* findY */3], param[/* resolution */2], Cdf$PredictionAnalysis.toPdf(param[/* agentPrediction */0])));
}

function marketPercentagePercentage(param) {
  var resolution = param[/* resolution */2];
  var marketPrediction = param[/* marketPrediction */1];
  var agentPrediction = param[/* agentPrediction */0];
  var marketPrediction$1 = Percentage$PredictionAnalysis.toFloat(marketPrediction);
  var agentPrediction$1 = Percentage$PredictionAnalysis.toFloat(agentPrediction);
  var resolution$1 = Percentage$PredictionAnalysis.toFloat(resolution);
  var positiveFactor = resolution$1 * Math.log2(agentPrediction$1 / marketPrediction$1);
  var marketPrediction$2 = Percentage$PredictionAnalysis.toFloat(Percentage$PredictionAnalysis.inverse(marketPrediction));
  var agentPrediction$2 = Percentage$PredictionAnalysis.toFloat(Percentage$PredictionAnalysis.inverse(agentPrediction));
  var resolution$2 = Percentage$PredictionAnalysis.toFloat(Percentage$PredictionAnalysis.inverse(resolution));
  var negativeFactor = resolution$2 * Math.log2(agentPrediction$2 / marketPrediction$2);
  var match = Percentage$PredictionAnalysis.toFloat(resolution);
  if (match !== 0.0) {
    if (match !== 1.0) {
      return positiveFactor + negativeFactor;
    } else {
      return positiveFactor;
    }
  } else {
    return negativeFactor;
  }
}

function nonMarketPercentagePercentage(param) {
  var resolution = param[/* resolution */2];
  var agentPrediction = param[/* agentPrediction */0];
  var agentPrediction$1 = Percentage$PredictionAnalysis.toFloat(agentPrediction);
  var resolution$1 = Percentage$PredictionAnalysis.toFloat(resolution);
  var positiveFactor = resolution$1 * Math.log2(agentPrediction$1 / resolution$1);
  var agentPrediction$2 = Percentage$PredictionAnalysis.toFloat(Percentage$PredictionAnalysis.inverse(agentPrediction));
  var resolution$2 = Percentage$PredictionAnalysis.toFloat(Percentage$PredictionAnalysis.inverse(resolution));
  var negativeFactor = resolution$2 * Math.log2(agentPrediction$2 / resolution$2);
  var match = Percentage$PredictionAnalysis.toFloat(resolution);
  if (match !== 0.0) {
    if (match !== 1.0) {
      return positiveFactor + negativeFactor;
    } else {
      return positiveFactor;
    }
  } else {
    return negativeFactor;
  }
}

function run(scoringCombination, sampleCount, param) {
  if (scoringCombination[0] >= 463448073) {
    var match = scoringCombination[1];
    var variant = match[0];
    if (variant !== 563749152) {
      if (variant >= 1067596532) {
        return /* Ok */Block.__(0, [nonMarketPercentagePercentage(match[1])]);
      } else {
        return /* Ok */Block.__(0, [nonMarketCdfFloat(match[1])]);
      }
    } else {
      return /* Ok */Block.__(0, [nonMarketCdfCdf(sampleCount, match[1])]);
    }
  } else {
    var match$1 = scoringCombination[1];
    var variant$1 = match$1[0];
    if (variant$1 !== 563749152) {
      if (variant$1 >= 1067596532) {
        return /* Ok */Block.__(0, [marketPercentagePercentage(match$1[1])]);
      } else {
        return /* Ok */Block.__(0, [marketCdfFloat(match$1[1])]);
      }
    } else {
      return /* Ok */Block.__(0, [marketCdfCdf(sampleCount, match$1[1])]);
    }
  }
}

function ofCdf(sampleCount, cdf) {
  return CdfLibraryImporter$PredictionAnalysis.Distribution[/* differentialEntropy */4](sampleCount, Cdf$PredictionAnalysis.toDistribution(cdf));
}

function ofPercentage(p) {
  var p$1 = Percentage$PredictionAnalysis.toFloat(p);
  var positiveFactor = p$1 * Math.log2(p$1);
  var p$2 = Percentage$PredictionAnalysis.toFloat(Percentage$PredictionAnalysis.inverse(p));
  var negativeFactor = p$2 * Math.log2(p$2);
  return positiveFactor + negativeFactor;
}

function run$1(sampleCount, m) {
  if (typeof m === "number") {
    return undefined;
  } else {
    var variant = m[0];
    if (variant !== -488794310) {
      if (variant !== 3354245) {
        return undefined;
      } else {
        return ofCdf(sampleCount, m[1]);
      }
    } else {
      return ofPercentage(m[1]);
    }
  }
}

var predictionGroupError = run;

var differentialEntropy = run$1;

exports.predictionGroupError = predictionGroupError;
exports.differentialEntropy = differentialEntropy;
/* Cdf-PredictionAnalysis Not a pure module */
